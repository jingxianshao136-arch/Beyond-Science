<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI çµæ„Ÿå¡”ç½— - é«˜æ€§èƒ½æ‰‹åŠ¿ç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        :root { --accent: #b287ff; }
        body { margin: 0; background: #05020a; color: white; font-family: sans-serif; overflow: hidden; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; width: 100%; }
        .hint-box { background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid var(--accent); border-radius: 8px; width: fit-content; pointer-events: auto; }
        #status { color: var(--accent); font-weight: bold; font-size: 20px; text-shadow: 0 0 10px var(--accent); }
        #cam-view { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; border: 2px solid var(--accent); border-radius: 10px; transform: scaleX(-1); }
        .log-list { position: absolute; right: 20px; top: 20px; width: 200px; max-height: 50vh; overflow-y: auto; background: rgba(20,20,40,0.6); padding: 10px; font-size: 12px; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="hint-box">
            <div id="status">ç³»ç»Ÿå‡†å¤‡ä¸­...</div>
            <div style="font-size: 12px; margin-top: 5px; color: #aaa;">
                ğŸ‘‹ å·¦å³æŒ¥åŠ¨æ‰‹æŒï¼šæ´—ç‰Œ<br>
                ğŸ‘Œ æåˆæ‰‹æŒ‡ï¼šæŠ½ç‰Œ<br>
                ğŸ– æ¡æ‹³åå¼ å¼€ï¼šç¿»å¼€çœ‹ç‰Œ
            </div>
            <select id="spread-type" style="margin-top:10px; pointer-events:auto;" onchange="changeSpread(this.value)">
                <option value="single">å•å¼ å¯ç¤º</option>
                <option value="three">ä¸‰æ—¶ç‰Œé˜µ</option>
                <option value="cross">åå­—æ‹äºº</option>
            </select>
        </div>
        <div id="log" class="log-list"></div>
    </div>

    <canvas id="cam-view"></canvas>
    <video id="input_video" style="display:none"></video>

<script>
/** 1. ç‰Œåº“æ•°æ®ä¸çŠ¶æ€ç®¡ç† **/
const CARD_BASE_URL = "https://raw.githubusercontent.com/the-prodigal-son/tarot-api/master/static/cards/";
const MajorNames = ['Fool','Magician','Priestess','Empress','Emperor','Hierophant','Lovers','Chariot','Strength','Hermit','Wheel','Justice','HangedMan','Death','Temperance','Devil','Tower','Star','Moon','Sun','Judgement','World'];
const SUITS = ['cups', 'pentacles', 'swords', 'wands'];
const FACES = ['01','02','03','04','05','06','07','08','09','10','page','knight','queen','king'];

let deckPool = [];
const buildPool = () => {
    deckPool = [];
    MajorNames.forEach((_, i) => deckPool.push({ id: `ar${i.toString().padStart(2, '0')}`, name: MajorNames[i] }));
    SUITS.forEach(s => FACES.forEach(f => deckPool.push({ id: s[0]+f, name: `${f} of ${s}` })));
    deckPool.sort(() => Math.random() - 0.5);
};

/** 2. Three.js æ ¸å¿ƒ **/
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶DPIé˜²æ­¢å¡é¡¿
document.body.appendChild(renderer.domElement);

const light = new THREE.SpotLight(0xffffff, 100);
light.position.set(0, 5, 10);
scene.add(new THREE.AmbientLight(0x4040ff, 2), light);
camera.position.z = 10;

const loader = new THREE.TextureLoader();
const backTex = loader.load('https://upload.wikimedia.org/wikipedia/commons/5/54/Tarot_Back.jpg');

let drawnMeshes = [];
let shuffleGroup = new THREE.Group();
scene.add(shuffleGroup);

/** 3. åŠ¨ç”»ä¸æ‰‹åŠ¿é€»è¾‘ **/
const SPREADS = {
    single: [{x:0, y:0, label: "å¿ƒä¹‹æ‰€å‘"}],
    three: [{x:-3, y:0, label: "è¿‡å»"}, {x:0, y:0, label: "ç°åœ¨"}, {x:3, y:0, label: "æœªæ¥"}],
    cross: [{x:0, y:0, label: "ç°çŠ¶"}, {x:0, y:0, z:0.5, rz:Math.PI/2, label: "éšœç¢"}, {x:0, y:2.5, label: "é«˜ä½"}, {x:0, y:-2.5, label: "æ ¹åŸº"}, {x:3, y:0, label: "ç¯å¢ƒ"}]
};
let currentMode = 'single';

function performShuffle() {
    buildPool();
    drawnMeshes.forEach(m => scene.remove(m));
    drawnMeshes = [];
    shuffleGroup.clear();
    
    // ç®€åŒ–æ´—ç‰Œè§†è§‰ï¼šåªç”¨15å¼ ä»£è¡¨ç‰Œæé«˜æ€§èƒ½
    for(let i=0; i<15; i++) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 3.2, 0.05), new THREE.MeshStandardMaterial({map: backTex}));
        mesh.position.y = -10;
        shuffleGroup.add(mesh);
        gsap.to(mesh.position, {
            x: (Math.random()-0.5)*3, y: -4, z: i*0.1,
            rotationY: Math.random()*2,
            duration: 0.8, delay: i*0.02
        });
    }
    document.getElementById('status').innerText = "âœ¨ æ´—ç‰Œä¸­...";
    setTimeout(() => document.getElementById('status').innerText = "ğŸ‘Œ è¯·æåˆæ‰‹æŒ‡æŠ½ç‰Œ", 1000);
}

function drawCard(handX, handY) {
    if (drawnMeshes.length >= SPREADS[currentMode].length) return;

    const cardInfo = deckPool.splice(Math.floor(Math.random()*deckPool.length), 1)[0];
    const isRev = Math.random() > 0.5;
    
    const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(2, 3.2, 0.1),
        [new THREE.MeshStandardMaterial({color:0x222}),new THREE.MeshStandardMaterial({color:0x222}),new THREE.MeshStandardMaterial({color:0x222}),new THREE.MeshStandardMaterial({color:0x222}),
         new THREE.MeshStandardMaterial({color:0x111}), // åˆå§‹æ­£é¢é»‘è‰²
         new THREE.MeshStandardMaterial({map: backTex})]
    );
    mesh.cardData = cardInfo;
    mesh.isReversed = isRev;
    mesh.isRevealed = false;
    mesh.position.set(handX, handY, 2);
    scene.add(mesh);
    drawnMeshes.push(mesh);

    const config = SPREADS[currentMode][drawnMeshes.length-1];
    gsap.to(mesh.position, { x: config.x, y: config.y, z: config.z || 0, duration: 1 });
    if(config.rz) gsap.to(mesh.rotation, { z: config.rz, duration: 1 });
}

function revealAll() {
    drawnMeshes.forEach(mesh => {
        if (mesh.isRevealed) return;
        mesh.isRevealed = true;
        // åŠ¨æ€åŠ è½½çº¹ç†ï¼ŒèŠ‚çœåˆå§‹å†…å­˜
        loader.load(`${CARD_BASE_URL}${mesh.cardData.id}.jpg`, (tex) => {
            mesh.material[4].map = tex;
            mesh.material[4].needsUpdate = true;
            gsap.to(mesh.rotation, { y: Math.PI, z: mesh.isReversed ? Math.PI : (mesh.rotation.z || 0), duration: 1.2 });
        });
    });
    document.getElementById('status').innerText = "ğŸ‘ï¸ å‘½è¿å·²æ­ç¤º";
}

/** 4. MediaPipe é«˜æ€§èƒ½æ£€æµ‹ **/
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('cam-view');
const ctx = canvasElement.getContext('2d');

let lastX = 0;
let pinchCooldown = false;
let lastFistState = false;

const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6 }); // modelComplexity:0 å¤§å¹…æå‡å¸§ç‡

hands.onResults(results => {
    ctx.save();
    ctx.clearRect(0,0,240,180);
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const h = results.multiHandLandmarks[0];
        
        // --- 1. æ´—ç‰Œæ‰‹åŠ¿ï¼šæ£€æµ‹Xè½´æ‘†åŠ¨é€Ÿåº¦ ---
        const currentX = h[9].x;
        const speed = Math.abs(currentX - lastX);
        if (speed > 0.08 && h[8].y < h[7].y) { // å¿«é€ŸæŒ¥åŠ¨æ‰‹æŒ
            performShuffle();
        }
        lastX = currentX;

        // --- 2. æŠ½ç‰Œæ‰‹åŠ¿ï¼šæåˆ (Pinch) ---
        const dist = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
        if (dist < 0.04 && !pinchCooldown) {
            drawCard((0.5-h[8].x)*15, (0.5-h[8].y)*10);
            pinchCooldown = true;
            setTimeout(() => pinchCooldown = false, 1000);
        }

        // --- 3. çœ‹ç‰Œæ‰‹åŠ¿ï¼šæ¡æ‹³å±•å¼€ (Fist to Open) ---
        const isFist = h[8].y > h[6].y && h[12].y > h[10].y;
        if (lastFistState && !isFist) { // ä»æ¡æ‹³å˜ä¸ºå¼ å¼€
            revealAll();
        }
        lastFistState = isFist;

        // ç»˜åˆ¶è¾…åŠ©çº¿
        drawConnectors(ctx, h, HAND_CONNECTIONS, {color: '#b287ff', lineWidth: 2});
    }
    ctx.restore();
});

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => await hands.send({image: videoElement}),
    width: 640, height: 480
});
cameraUtils.start();

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();
function changeSpread(v) { currentMode = v; performShuffle(); }
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
