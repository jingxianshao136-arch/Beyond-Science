<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI çµåŠ¨å¡”ç½— - æé€Ÿç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        /* ç¡®ä¿æ‘„åƒå¤´ç”»é¢åœ¨æœ€ä¸Šå±‚æ˜¾ç¤ºï¼Œæ–¹ä¾¿è°ƒè¯• */
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; background: rgba(10, 5, 20, 0.8); border: 1px solid #6e45e2; padding: 15px; margin: 20px; border-radius: 12px; width: 220px; }
        #cam-layer { position: absolute; bottom: 20px; right: 20px; width: 320px; height: 240px; border: 2px solid #00f2fe; border-radius: 10px; background: #111; z-index: 100; }
        #status-msg { color: #00f2fe; font-weight: bold; text-transform: uppercase; font-size: 14px; margin-bottom: 10px; }
        canvas.output_canvas { width: 100%; height: 100%; transform: scaleX(-1); }
        .btn { background: #6e45e2; color: white; border: none; padding: 8px; width: 100%; cursor: pointer; border-radius: 4px; margin-top: 5px; }
    </style>
</head>
<body>

    <div id="ui-container">
        <div class="panel">
            <div id="status-msg">ç³»ç»Ÿåˆå§‹åŒ–...</div>
            <div style="font-size: 11px; opacity: 0.7;">
                ğŸ‘‹ æŒ¥æ‰‹ï¼šæ´—ç‰Œ<br>
                ğŸ‘Œ æåˆï¼šæŠ½ç‰Œ<br>
                âœŠ->ğŸ– å¼ å¼€æ‹³å¤´ï¼šçœ‹ç‰Œ
            </div>
            <select id="spread" style="margin-top:10px; pointer-events:auto;" onchange="changeSpread(this.value)">
                <option value="single">å•å¼ å¯ç¤º</option>
                <option value="three">ä¸‰åœ£ä¸‰è§’</option>
                <option value="cross">åå­—é˜µ</option>
            </select>
            <button class="btn" onclick="startCamera()">é‡è¯•æ‘„åƒå¤´</button>
        </div>
    </div>

    <div id="cam-layer">
        <video id="input_video" style="display:none"></video>
        <canvas class="output_canvas"></canvas>
    </div>

<script>
/** 1. æ ¸å¿ƒçŠ¶æ€ä¸ç‰Œåº“ **/
const API_URL = "https://raw.githubusercontent.com/the-prodigal-son/tarot-api/master/static/cards/";
let deckPool = [];
const SPREADS = {
    single: [{x:0, y:0, l: "å¯ç¤º"}],
    three: [{x:-3, y:0, l: "è¿‡å»"}, {x:0, y:0, l: "ç°åœ¨"}, {x:3, y:0, l: "æœªæ¥"}],
    cross: [{x:0, y:0, l: "ç°çŠ¶"}, {x:0, y:0, z:0.5, rz:Math.PI/2, l: "é˜»ç¢"}, {x:0, y:2.5, l: "é«˜ä½"}, {x:0, y:-2.5, l: "åŸºç¡€"}, {x:3, y:0, l: "å¤–éƒ¨"}]
};
let currentMode = 'single';
let drawnMeshes = [];

// åˆå§‹åŒ–ç‰Œæ± ï¼ˆæ— å›¾ç‰‡ï¼‰
function buildPool() {
    deckPool = [];
    for(let i=0; i<22; i++) deckPool.push({id:`ar${i.toString().padStart(2,'0')}`, n:'Major'});
    ['cups','pentacles','swords','wands'].forEach(s => {
        ['01','02','03','04','05','06','07','08','09','10','page','knight','queen','king'].forEach(f => {
            deckPool.push({id: s[0]+f, n: `${f} of ${s}`});
        });
    });
    deckPool.sort(() => Math.random() - 0.5);
}

/** 2. Three.js æé€Ÿæ¸²æŸ“å¼•æ“ **/
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(1); // å¼ºåˆ¶ 1.0 åƒç´ æ¯”ï¼Œæå…¶æµç•…
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0x4433aa, 1.5);
const point = new THREE.PointLight(0x00f2fe, 5, 20);
point.position.set(0, 5, 5);
scene.add(ambient, point);
camera.position.z = 10;

// é¢„åŠ è½½å•å¼ èƒŒé¢å›¾
const loader = new THREE.TextureLoader();
const backTex = loader.load('https://upload.wikimedia.org/wikipedia/commons/5/54/Tarot_Back.jpg');

// å‘å…‰è¾¹ç¼˜æè´¨
const glowMaterial = new THREE.MeshBasicMaterial({ color: 0x00f2fe, wireframe: true, transparent: true, opacity: 0.3 });

let visualDeck = []; // ç”¨äºæ´—ç‰Œçš„é•¿å»Šå¡ç‰Œ
function createVisualDeck() {
    visualDeck.forEach(m => scene.remove(m));
    visualDeck = [];
    const geo = new THREE.BoxGeometry(2, 3.2, 0.02);
    for(let i=0; i<20; i++) {
        const m = new THREE.Mesh(geo, glowMaterial);
        m.position.set((i-10)*0.8, -4, -i*0.2);
        scene.add(m);
        visualDeck.push(m);
    }
}

/** 3. æ‰‹åŠ¿ä¸æ¸¸æˆé€»è¾‘ **/
function shuffleEffect() {
    document.getElementById('status-msg').innerText = "ğŸ”® çµåŠ›æ´—ç‰Œä¸­...";
    buildPool();
    drawnMeshes.forEach(m => scene.remove(m));
    drawnMeshes = [];
    
    visualDeck.forEach((m, i) => {
        gsap.to(m.position, {
            x: (Math.random()-0.5)*5, y: (Math.random()-0.5)*3, z: (Math.random()-0.5)*2,
            duration: 0.5, repeat: 1, yoyo: true,
            ease: "sine.inOut"
        });
    });
}

function drawOne(hx, hy) {
    if (drawnMeshes.length >= SPREADS[currentMode].length) return;
    const data = deckPool.pop();
    const isRev = Math.random() > 0.5;

    // åˆ›å»ºå®ç‰©ç‰Œ
    const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(2, 3.2, 0.1),
        [
            new THREE.MeshStandardMaterial({color:0x333}), new THREE.MeshStandardMaterial({color:0x333}),
            new THREE.MeshStandardMaterial({color:0x333}), new THREE.MeshStandardMaterial({color:0x333}),
            new THREE.MeshStandardMaterial({color:0x000}), // é¢„ç•™æ­£é¢
            new THREE.MeshStandardMaterial({map: backTex}) // èƒŒé¢
        ]
    );
    mesh.cardData = data;
    mesh.isReversed = isRev;
    mesh.position.set(hx, hy, 2);
    scene.add(mesh);
    drawnMeshes.push(mesh);

    const cfg = SPREADS[currentMode][drawnMeshes.length-1];
    gsap.to(mesh.position, { x: cfg.x, y: cfg.y, z: cfg.z || 0, duration: 1, ease: "back.out" });
    if(cfg.rz) gsap.to(mesh.rotation, { z: cfg.rz, duration: 1 });

    // åå°ç«‹åˆ»é¢„å–è¯¥å¡ç‰Œè´´å›¾
    loader.load(`${API_URL}${data.id}.jpg`, (tex) => {
        mesh.material[4].map = tex;
        mesh.material[4].needsUpdate = true;
    });
}

function revealAll() {
    document.getElementById('status-msg').innerText = "ğŸ‘ï¸ å‘½è¿æ­æ™“";
    drawnMeshes.forEach(m => {
        gsap.to(m.rotation, { y: Math.PI, z: m.isReversed ? Math.PI : (m.rotation.z || 0), duration: 1.5 });
    });
}

/** 4. æ‘„åƒå¤´ä¸ AI æ£€æµ‹ (ä¿®å¤é»‘è‰²å±å¹•) **/
const video = document.getElementById('input_video');
const canvas = document.querySelector('.output_canvas');
const ctx = canvas.getContext('2d');

const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6 });

let lastX = 0, lastFist = false, cooldown = false;

hands.onResults(results => {
    // å³ä½¿æ²¡æ‰‹ä¹Ÿè¦ç”»èƒŒæ™¯
    ctx.save();
    ctx.clearRect(0,0,canvas.width, canvas.height);
    if(results.image) ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const h = results.multiHandLandmarks[0];
        
        // æ´—ç‰Œæ£€æµ‹
        if (Math.abs(h[9].x - lastX) > 0.08) shuffleEffect();
        lastX = h[9].x;

        // æåˆæŠ½ç‰Œ
        const dist = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
        if (dist < 0.04 && !cooldown) {
            drawOne((0.5-h[8].x)*15, (0.5-h[8].y)*10);
            cooldown = true; setTimeout(() => cooldown = false, 1500);
        }

        // æ¡æ‹³å±•å¼€çœ‹ç‰Œ
        const isFist = h[8].y > h[6].y && h[12].y > h[10].y;
        if (lastFist && !isFist) revealAll();
        lastFist = isFist;

        // ç”»æ‰‹éƒ¨éª¨æ¶
        window.drawConnectors(ctx, h, HAND_CONNECTIONS, {color: '#00f2fe', lineWidth: 3});
        window.drawLandmarks(ctx, h, {color: '#fff', lineWidth: 1, radius: 2});
    }
    ctx.restore();
});

function startCamera() {
    const cam = new Camera(video, {
        onFrame: async () => await hands.send({image: video}),
        width: 640, height: 480
    });
    cam.start().then(() => {
        document.getElementById('status-msg').innerText = "âœ… é“¾æ¥æˆåŠŸ";
    }).catch(e => {
        document.getElementById('status-msg').innerText = "âŒ æ‘„åƒå¤´è¢«æ‹¦æˆª";
        console.error(e);
    });
}

// æ¸²æŸ“å¾ªç¯
function animate() {
    requestAnimationFrame(animate);
    visualDeck.forEach((m, i) => m.rotation.y = Math.sin(Date.now()*0.001 + i) * 0.1);
    renderer.render(scene, camera);
}

startCamera();
createVisualDeck();
buildPool();
animate();

function changeSpread(v) { currentMode = v; shuffleEffect(); }
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
