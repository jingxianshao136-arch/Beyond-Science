<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI å¡”ç½—å åœ - ç¨³å®šå¢å¼ºç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'PingFang SC', sans-serif; }
        #webgl-canvas { position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* æ‘„åƒå¤´å°çª—ä¼˜åŒ– */
        #cam-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 240px; height: 180px;
            border: 2px solid #00f2fe; border-radius: 12px;
            overflow: hidden; z-index: 100; background: #111;
        }
        #output_canvas { width: 100%; height: 100%; transform: scaleX(-1); }
        
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 101;
            background: rgba(15, 5, 30, 0.85); color: #00f2fe;
            padding: 20px; border-radius: 15px; border: 1px solid #6e45e2;
            pointer-events: auto; width: 220px;
        }
        .status-tag { font-weight: bold; font-size: 18px; margin-bottom: 10px; display: block; }
        .hint { font-size: 12px; color: #aaa; line-height: 1.6; }
    </style>
</head>
<body>

    <div id="ui">
        <span class="status-tag" id="status">ç³»ç»Ÿå‡†å¤‡å°±ç»ª</span>
        <div class="hint">
            ğŸ‘‹ æŒ¥æ‰‹ï¼šæ´—ç‰Œ / é‡ç½®<br>
            ğŸ‘Œ æåˆï¼šæŠ½å–å•å¼ <br>
            âœŠ->ğŸ– å¼ å¼€ï¼šç¿»å¼€å…¨åœº
        </div>
        <button onclick="location.reload()" style="margin-top:15px; width:100%; background:#6e45e2; color:white; border:none; padding:8px; cursor:pointer; border-radius:5px;">é‡å¯è®¾å¤‡æµ</button>
    </div>

    <div id="cam-container">
        <canvas id="output_canvas"></canvas>
    </div>
    
    <video id="input_video" style="display:none" playsinline></video>

<script>
/** 1. åŸºç¡€é…ç½® **/
const API_URL = "https://raw.githubusercontent.com/the-prodigal-son/tarot-api/master/static/cards/";
const backTexUrl = 'https://upload.wikimedia.org/wikipedia/commons/5/54/Tarot_Back.jpg';
let deckPool = [], drawnCards = [], visualDeck = [];

/** 2. Three.js åˆå§‹åŒ– **/
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.domElement.id = "webgl-canvas";
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const pointLight = new THREE.PointLight(0x00f2fe, 10, 50);
pointLight.position.set(0, 5, 5);
scene.add(pointLight);
camera.position.z = 12;

const loader = new THREE.TextureLoader();
const backTex = loader.load(backTexUrl);
const glowMat = new THREE.MeshBasicMaterial({ color: 0x00f2fe, wireframe: true, transparent: true, opacity: 0.4 });

// åˆ›å»ºæ´—ç‰Œç”¨çš„éœ“è™¹çº¿æ¡†ç‰Œå †
function initVisualDeck() {
    visualDeck.forEach(d => scene.remove(d));
    visualDeck = [];
    for(let i=0; i<30; i++) {
        const m = new THREE.Mesh(new THREE.BoxGeometry(2.2, 3.8, 0.01), glowMat);
        m.position.set(0, -5, -i*0.1);
        scene.add(m);
        visualDeck.push(m);
    }
}

/** 3. æ¸¸æˆé€»è¾‘ **/
function shuffle() {
    document.getElementById('status').innerText = "ğŸ”® æ´—ç‰Œä¸­...";
    deckPool = [];
    for(let i=0; i<22; i++) deckPool.push(`ar${i.toString().padStart(2,'0')}`);
    deckPool.sort(() => Math.random() - 0.5);
    
    drawnCards.forEach(c => scene.remove(c));
    drawnCards = [];

    visualDeck.forEach((m, i) => {
        gsap.to(m.position, {
            x: (Math.random()-0.5)*10, y: (Math.random()-0.5)*5,
            duration: 0.4, yoyo: true, repeat: 1,
            onComplete: () => {
                gsap.to(m.position, { x: (i-15)*0.5, y: -4.5, z: 0, duration: 0.8 });
            }
        });
    });
}

function draw(x, y) {
    if (drawnCards.length >= 3 || deckPool.length === 0) return;
    const id = deckPool.pop();
    const isRev = Math.random() > 0.5;

    const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(2.5, 4, 0.1),
        [
            new THREE.MeshStandardMaterial({color:0x222}), new THREE.MeshStandardMaterial({color:0x222}),
            new THREE.MeshStandardMaterial({color:0x222}), new THREE.MeshStandardMaterial({color:0x222}),
            new THREE.MeshStandardMaterial({color:0x111}), // åˆå§‹æ— å›¾
            new THREE.MeshStandardMaterial({map: backTex})
        ]
    );
    mesh.position.set(x, y, 2);
    mesh.cardId = id;
    mesh.isRev = isRev;
    scene.add(mesh);
    drawnCards.push(mesh);

    gsap.to(mesh.position, { x: (drawnCards.length - 2) * 3.5, y: 1, z: 0, duration: 1, ease: "back.out" });
    
    // é¢„çƒ­åŠ è½½
    loader.load(`${API_URL}${id}.jpg`, (t) => {
        mesh.material[4].map = t;
        mesh.material[4].needsUpdate = true;
    });
}

function flipAll() {
    document.getElementById('status').innerText = "ğŸ‘ï¸ å‘½è¿æ­æ™“";
    drawnCards.forEach(m => {
        gsap.to(m.rotation, { y: Math.PI, z: m.isRev ? Math.PI : 0, duration: 1.2 });
    });
}

/** 4. æ‘„åƒå¤´æ ¸å¿ƒé©±åŠ¨ (ä¿®å¤ä¸­æ–­é—®é¢˜) **/
const video = document.getElementById('input_video');
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d');

const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.7 });

let lastX = 0, lastFist = false, cooldown = false;

hands.onResults(res => {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    if (res.image) {
        ctx.save();
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(res.image, 0, 0, canvas.width, canvas.height);
        ctx.restore();
    }
    
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        const h = res.multiHandLandmarks[0];
        // æ¸²æŸ“éª¨æ¶
        for (const conn of HAND_CONNECTIONS) {
            const from = h[conn[0]], to = h[conn[1]];
            ctx.beginPath();
            ctx.moveTo(from.x * canvas.width, from.y * canvas.height);
            ctx.lineTo(to.x * canvas.width, to.y * canvas.height);
            ctx.strokeStyle = '#00f2fe'; ctx.lineWidth = 3; ctx.stroke();
        }

        // æ‰‹åŠ¿é€»è¾‘
        if (Math.abs(h[9].x - lastX) > 0.12) shuffle();
        lastX = h[9].x;

        const d = Math.hypot(h[4].x-h[8].x, h[4].y-h[8].y);
        if (d < 0.05 && !cooldown) {
            draw((0.5-h[8].x)*15, (0.5-h[8].y)*10);
            cooldown = true; setTimeout(()=>cooldown=false, 1500);
        }

        const isFist = h[8].y > h[6].y && h[12].y > h[10].y;
        if (lastFist && !isFist) flipAll();
        lastFist = isFist;
    }
});

// ä½¿ç”¨åº•å±‚ API å¯åŠ¨æ‘„åƒå¤´ï¼Œé˜²æ­¢è‡ªåŠ¨ä¸­æ–­
async function initCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
        video.srcObject = stream;
        await video.play();
        
        canvas.width = 640; canvas.height = 480;

        const process = async () => {
            if (video.paused || video.ended) return;
            await hands.send({ image: video });
            video.requestVideoFrameCallback(process); // é«˜æ•ˆç‡å¾ªç¯
        };
        video.requestVideoFrameCallback(process);
    } catch (err) {
        document.getElementById('status').innerText = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥";
        console.error(err);
    }
}

/** 5. å¯åŠ¨ **/
function animate() {
    requestAnimationFrame(animate);
    visualDeck.forEach((m, i) => {
        m.rotation.y = Math.sin(Date.now()*0.001 + i) * 0.1;
    });
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

initCamera();
initVisualDeck();
shuffle();
animate();

</script>
</body>
</html>
