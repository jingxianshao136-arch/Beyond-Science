<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AI Tarot Divination</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle, #1a0a2e 0%, #05020a 100%); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #e0d5ff; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #status-bar { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(20, 10, 40, 0.8); padding: 10px 30px; border-radius: 50px; border: 1px solid #6a4caf; backdrop-filter: blur(5px); font-size: 14px; text-transform: uppercase; letter-spacing: 2px; }
        #history { position: absolute; left: 20px; top: 80px; width: 200px; max-height: 70vh; overflow-y: auto; pointer-events: auto; background: rgba(0,0,0,0.4); padding: 15px; border-radius: 10px; font-size: 12px; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; border: 2px solid #6a4caf; border-radius: 10px; overflow: hidden; transform: scaleX(-1); background: #000; }
        canvas.output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .log-entry { margin-bottom: 8px; border-bottom: 1px solid #332255; padding-bottom: 4px; }
        .reversed { color: #ff6b6b; font-style: italic; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="status-bar">Initializing Mystical Connection...</div>
        <div id="history"><strong>JOURNAL OF FATE</strong><hr></div>
    </div>

    <div id="video-container">
        <video id="input_video" style="display:none"></video>
        <canvas class="output_canvas"></canvas>
    </div>

<script>
/** * TAROT CONFIGURATION 
 */
const MAJOR_ARCANA = [
    { name: "The Fool", url: "https://upload.wikimedia.org/wikipedia/en/9/90/RWS_Tarot_00_Fool.jpg" },
    { name: "The Magician", url: "https://upload.wikimedia.org/wikipedia/en/d/de/RWS_Tarot_01_Magician.jpg" },
    { name: "The High Priestess", url: "https://upload.wikimedia.org/wikipedia/en/8/8d/RWS_Tarot_02_High_Priestess.jpg" },
    { name: "The Empress", url: "https://upload.wikimedia.org/wikipedia/en/d/d2/RWS_Tarot_03_Empress.jpg" },
    { name: "The Emperor", url: "https://upload.wikimedia.org/wikipedia/en/c/c3/RWS_Tarot_04_Emperor.jpg" },
    { name: "The Hierophant", url: "https://upload.wikimedia.org/wikipedia/en/8/8d/RWS_Tarot_05_Hierophant.jpg" },
    { name: "The Lovers", url: "https://upload.wikimedia.org/wikipedia/en/d/db/RWS_Tarot_06_Lovers.jpg" },
    { name: "The Chariot", url: "https://upload.wikimedia.org/wikipedia/en/9/9b/RWS_Tarot_07_Chariot.jpg" },
    { name: "Strength", url: "https://upload.wikimedia.org/wikipedia/en/f/f5/RWS_Tarot_08_Strength.jpg" },
    { name: "The Hermit", url: "https://upload.wikimedia.org/wikipedia/en/4/4d/RWS_Tarot_09_Hermit.jpg" },
    { name: "Wheel of Fortune", url: "https://upload.wikimedia.org/wikipedia/en/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg" },
    { name: "Justice", url: "https://upload.wikimedia.org/wikipedia/en/e/e0/RWS_Tarot_11_Justice.jpg" },
    { name: "The Hanged Man", url: "https://upload.wikimedia.org/wikipedia/en/2/2b/RWS_Tarot_12_Hanged_Man.jpg" },
    { name: "Death", url: "https://upload.wikimedia.org/wikipedia/en/d/d7/RWS_Tarot_13_Death.jpg" },
    { name: "Temperance", url: "https://upload.wikimedia.org/wikipedia/en/f/f8/RWS_Tarot_14_Temperance.jpg" },
    { name: "The Devil", url: "https://upload.wikimedia.org/wikipedia/en/5/55/RWS_Tarot_15_Devil.jpg" },
    { name: "The Tower", url: "https://upload.wikimedia.org/wikipedia/en/5/53/RWS_Tarot_16_Tower.jpg" },
    { name: "The Star", url: "https://upload.wikimedia.org/wikipedia/en/d/db/RWS_Tarot_17_Star.jpg" },
    { name: "The Moon", url: "https://upload.wikimedia.org/wikipedia/en/7/7f/RWS_Tarot_18_Moon.jpg" },
    { name: "The Sun", url: "https://upload.wikimedia.org/wikipedia/en/1/17/RWS_Tarot_19_Sun.jpg" },
    { name: "Judgement", url: "https://upload.wikimedia.org/wikipedia/en/d/dd/RWS_Tarot_20_Judgement.jpg" },
    { name: "The World", url: "https://upload.wikimedia.org/wikipedia/en/f/ff/RWS_Tarot_21_World.jpg" }
];

let deck = [...MAJOR_ARCANA].sort(() => Math.random() - 0.5);
let currentCard = null;
let isDrawing = false;
let particles = null;

/**
 * THREE.JS SETUP
 */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0x4040ff, 0.6);
scene.add(ambientLight);

const spotLight = new THREE.SpotLight(0xffffff, 1.5);
spotLight.position.set(0, 5, 5);
scene.add(spotLight);

camera.position.z = 5;

/**
 * CARD GENERATION
 */
const textureLoader = new THREE.TextureLoader();
const cardBack = textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/5/54/Tarot_Back.jpg');

function createCardMesh(cardData) {
    const geometry = new THREE.BoxGeometry(2.5, 4, 0.1);
    const frontTex = textureLoader.load(cardData.url);
    const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
    
    const materials = [
        goldMat, goldMat, goldMat, goldMat,
        new THREE.MeshStandardMaterial({ map: frontTex }), // Front
        new THREE.MeshStandardMaterial({ map: cardBack })  // Back
    ];

    const mesh = new THREE.Mesh(geometry, materials);
    mesh.isReversed = Math.random() > 0.5;
    mesh.cardName = cardData.name;
    
    // Initial hidden state
    mesh.position.set(0, -10, 0);
    mesh.rotation.y = Math.PI; // Face down
    
    scene.add(mesh);
    return mesh;
}

/**
 * ASH DISSOLUTION EFFECT
 */
function triggerAshEffect(position) {
    const count = 500;
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const vel = new Float32Array(count * 3);

    for(let i=0; i<count*3; i+=3) {
        pos[i] = position.x + (Math.random() - 0.5) * 2;
        pos[i+1] = position.y + (Math.random() - 0.5) * 3;
        pos[i+2] = position.z;
        vel[i] = (Math.random() - 0.5) * 0.02;
        vel[i+1] = Math.random() * 0.05;
        vel[i+2] = (Math.random() - 0.5) * 0.02;
    }

    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ color: 0x888888, size: 0.05, transparent: true, opacity: 1 });
    const points = new THREE.Points(geo, mat);
    scene.add(points);

    gsap.to(mat, { opacity: 0, duration: 2, onComplete: () => scene.remove(points) });
    
    const animateAsh = () => {
        if (mat.opacity <= 0) return;
        const positions = points.geometry.attributes.position.array;
        for(let i=0; i<count*3; i+=3) {
            positions[i] += vel[i];
            positions[i+1] += vel[i+1];
            positions[i+2] += vel[i+2];
        }
        points.geometry.attributes.position.needsUpdate = true;
        requestAnimationFrame(animateAsh);
    };
    animateAsh();
}

/**
 * GAME LOGIC
 */
function drawNewCard() {
    if (deck.length === 0) {
        document.getElementById('status-bar').innerText = "The Deck is Empty.";
        return;
    }
    const data = deck.pop();
    currentCard = createCardMesh(data);
    gsap.to(currentCard.position, { y: 0, duration: 1.5, ease: "back.out(1.7)" });
    isDrawing = true;
}

function finalizeDraw() {
    if (!currentCard || !isDrawing) return;
    
    const log = document.getElementById('history');
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.innerHTML = `<strong>${currentCard.cardName}</strong> ${currentCard.isReversed ? '<span class="reversed">(Reversed)</span>' : ''}`;
    log.prepend(entry);

    triggerAshEffect(currentCard.position);
    scene.remove(currentCard);
    currentCard = null;
    isDrawing = false;
    
    setTimeout(drawNewCard, 2000);
}

/**
 * MEDIAPIPE GESTURE DETECTION
 */
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementsByClassName('output_canvas')[0];
const canvasCtx = canvasElement.getContext('2d');
const statusText = document.getElementById('status-bar');

function onResults(results) {
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const hand = results.multiHandLandmarks[0];
        drawConnectors(canvasCtx, hand, HAND_CONNECTIONS, {color: '#6a4caf', lineWidth: 5});
        drawLandmarks(canvasCtx, hand, {color: '#ff0077', lineWidth: 2});

        // Feature detection
        const thumbTip = hand[4];
        const indexTip = hand[8];
        const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
        
        // Map 0-1 range to Three.js coordinates
        const targetX = (0.5 - hand[9].x) * 10; 
        const targetY = (0.5 - hand[9].y) * 10;

        // Logic check: FIST (Confirm)
        const isFist = hand[8].y > hand[6].y && hand[12].y > hand[10].y;
        
        if (isFist) {
            statusText.innerText = "FIST: Confirming Fate...";
            finalizeDraw();
        } else if (distance < 0.05) {
            statusText.innerText = "PINCH: Examining Card...";
            if (currentCard) {
                gsap.to(currentCard.position, { x: targetX, y: targetY, z: 2, duration: 0.2 });
                gsap.to(currentCard.rotation, { 
                    y: 0, 
                    z: currentCard.isReversed ? Math.PI : 0, 
                    duration: 0.5 
                });
            }
        } else {
            statusText.innerText = "OPEN PALM: Hovering...";
            if (currentCard) {
                gsap.to(currentCard.position, { x: 0, y: 0, z: 0, duration: 0.5 });
                gsap.to(currentCard.rotation, { y: Math.PI, z: 0, duration: 0.5 });
            }
        }
    } else {
        statusText.innerText = "No Hand Detected - Fallback to Mouse";
    }
    canvasCtx.restore();
}

const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(onResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 640, height: 480
});
cameraUtils.start();

/**
 * INITIALIZATION
 */
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Start the game
animate();
drawNewCard();

</script>
</body>
</html>