<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Threeis - 灵感手势塔罗</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        /* UI 叠加层 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        
        #video-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 240px; height: 180px; border: 2px solid #444; border-radius: 8px;
            overflow: hidden; background: #000; transform: scaleX(-1);
        }
        canvas#output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        #history-panel {
            position: absolute; left: 20px; top: 20px; width: 200px; max-height: 80vh;
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px;
            backdrop-filter: blur(5px); overflow-y: auto; pointer-events: auto;
        }
        
        #status-bar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.1); padding: 10px 30px; border-radius: 30px;
            font-size: 1.2rem; border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-toggle {
            position: absolute; top: 20px; right: 20px; pointer-events: auto;
            padding: 10px 20px; background: #6366f1; border: none; color: white;
            border-radius: 5px; cursor: pointer;
        }

        #info-card {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -150%);
            text-align: center; width: 300px; pointer-events: none; opacity: 0;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="container"></div>

<div id="ui-layer">
    <button class="btn-toggle" id="modeBtn">模式: 摄像头</button>
    
    <div id="history-panel">
        <h3 style="margin-top:0">历史记录</h3>
        <div id="history-list"></div>
    </div>

    <div id="info-card">
        <h2 id="card-name">魔术师</h2>
        <p id="card-desc">正位：创造力、沟通、行动</p>
    </div>

    <div id="status-bar">准备中...</div>

    <div id="video-container">
        <video id="input_video" style="display:none"></video>
        <canvas id="output_canvas"></canvas>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/** -----------------------------------------------------------------
 * 配置与数据
 * ----------------------------------------------------------------- */
const TAROT_DATA = [
    { name: "愚者", up: "开始、自由", rev: "鲁莽、束缚" },
    { name: "魔术师", up: "创造力、行动", rev: "操纵、幻觉" },
    { name: "女祭司", up: "直觉、潜意识", rev: "被动、隔阂" },
    { name: "皇后", up: "丰饶、母性", rev: "依赖、缺乏安全感" },
    { name: "皇帝", up: "权威、结构", rev: "暴政、僵化" },
    // 此处可扩展至78张...
];

const CARD_ASSETS = {
    back: 'https://images.unsplash.com/photo-1572916169351-709566378cfd?q=80&w=400', // 占位牌背
    frontBase: 'https://raw.githubusercontent.com/jekyll/thoth-tarot/master/assets/images/cards/' // 示例图源
};

/** -----------------------------------------------------------------
 * Three.js 核心引擎
 * ----------------------------------------------------------------- */
let scene, camera, renderer, raycaster;
let deck = [], activeCard = null, particles = [];
let isCameraMode = true;
let mouse = new THREE.Vector2();

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0x6366f1, 1);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    raycaster = new THREE.Raycaster();
    
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    createDeck();
    animate();
}

function createDeck() {
    const geometry = new THREE.PlaneGeometry(2, 3);
    // 简化的牌堆逻辑：在屏幕中央生成一张待抽卡
    spawnNextCard();
}

function spawnNextCard() {
    if (activeCard) return;
    
    const cardIdx = Math.floor(Math.random() * TAROT_DATA.length);
    const data = TAROT_DATA[cardIdx];
    const isReversed = Math.random() < 0.5;

    const loader = new THREE.TextureLoader();
    const material = new THREE.MeshStandardMaterial({ 
        map: loader.load(CARD_ASSETS.back),
        side: THREE.DoubleSide 
    });

    const mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 0.05), material);
    mesh.position.set(0, -5, 0); // 从下方滑入
    mesh.userData = { ...data, isReversed, state: 'IDLE' };
    
    scene.add(mesh);
    activeCard = mesh;

    // 入场动画
    new Promise(res => {
        let startTime = Date.now();
        const anim = () => {
            let progress = (Date.now() - startTime) / 1000;
            if(progress < 1) {
                mesh.position.y = -5 + progress * 5;
                requestAnimationFrame(anim);
            } else {
                mesh.position.y = 0;
            }
        }
        anim();
    });
}

/** -----------------------------------------------------------------
 * 灰烬粒子系统 (Points)
 * ----------------------------------------------------------------- */
function createAshEffect(targetMesh) {
    const count = 500;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const velocities = new Float32Array(count * 3);
    const life = new Float32Array(count);

    for (let i = 0; i < count; i++) {
        positions[i * 3] = targetMesh.position.x + (Math.random() - 0.5) * 2;
        positions[i * 3 + 1] = targetMesh.position.y + (Math.random() - 0.5) * 3;
        positions[i * 3 + 2] = targetMesh.position.z;
        
        velocities[i * 3] = (Math.random() - 0.5) * 0.02;
        velocities[i * 3 + 1] = Math.random() * 0.05 + 0.02;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
        
        life[i] = 1.0;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const material = new THREE.PointsMaterial({
        size: 0.05,
        color: 0xaaaaaa,
        transparent: true,
        blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);
    particles.push({ mesh: points, velocities, life });

    // 记录到历史
    const record = document.createElement('div');
    record.innerHTML = `<small>${targetMesh.userData.isReversed ? '逆位' : '正位'}</small> <b>${targetMesh.userData.name}</b>`;
    document.getElementById('history-list').prepend(record);

    scene.remove(targetMesh);
    activeCard = null;
    setTimeout(spawnNextCard, 2000);
}

/** -----------------------------------------------------------------
 * MediaPipe 手势识别
 * ----------------------------------------------------------------- */
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');
let lastGesture = "NONE";

function onResults(results) {
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        // 绘制手部骨架（可选）
        // drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 5});

        const gesture = detectGesture(landmarks);
        handleInteraction(gesture, landmarks[9]); // 以掌心点(9)作为参考坐标
    } else {
        if(!isCameraMode) handleInteraction("MOUSE", null);
    }
    canvasCtx.restore();
}

function detectGesture(lm) {
    const dist = (p1, p2) => Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
    
    // Pinch: 食指尖(8)和拇指尖(4)
    const isPinch = dist(lm[8], lm[4]) < 0.05;
    // Open: 食指(8)和中指(12)都高于指根
    const isOpen = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y < lm[14].y;
    // Fist: 所有指尖低于指根
    const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y;
    // Point: 仅食指伸直
    const isPoint = lm[8].y < lm[6].y && lm[12].y > lm[10].y;

    if (isFist) return "FIST";
    if (isPinch) return "PINCH";
    if (isOpen) return "OPEN";
    if (isPoint) return "POINT";
    return "NONE";
}

/** -----------------------------------------------------------------
 * 交互逻辑控制器
 * ----------------------------------------------------------------- */
function handleInteraction(gesture, handPos) {
    const statusEl = document.getElementById('status-bar');
    statusEl.innerText = `当前状态: ${gesture}`;

    if (!activeCard) return;

    // 坐标转换 (MediaPipe 0~1 -> Three.js)
    let targetX = 0, targetY = 0;
    if (handPos) {
        targetX = (0.5 - handPos.x) * 10; // 镜像处理
        targetY = (0.5 - handPos.y) * 8;
    } else {
        targetX = mouse.x * 5;
        targetY = mouse.y * 5;
    }

    switch(gesture) {
        case "OPEN":
            activeCard.material.emissive = new THREE.Color(0x222222);
            break;
        case "PINCH":
            // 拉到面前
            activeCard.position.lerp(new THREE.Vector3(targetX, targetY, 2), 0.1);
            activeCard.rotation.y = Math.PI; // 翻转看正面
            if(activeCard.userData.isReversed) activeCard.rotation.z = Math.PI;
            
            showInfo(activeCard.userData);
            break;
        case "FIST":
            if (activeCard.position.z > 1) {
                createAshEffect(activeCard);
                hideInfo();
            }
            break;
        case "POINT":
            // 停止惯性，原地悬停
            break;
    }
}

function showInfo(data) {
    const el = document.getElementById('info-card');
    el.style.opacity = 1;
    document.getElementById('card-name').innerText = data.name + (data.isReversed ? " (逆位)" : " (正位)");
    document.getElementById('card-desc').innerText = data.isReversed ? data.rev : data.up;
}

function hideInfo() {
    document.getElementById('info-card').style.opacity = 0;
}

/** -----------------------------------------------------------------
 * 主循环
 * ----------------------------------------------------------------- */
function animate() {
    requestAnimationFrame(animate);

    // 更新粒子
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        const pos = p.mesh.geometry.attributes.position.array;
        for (let j = 0; j < p.life.length; j++) {
            pos[j*3] += p.velocities[j*3] + (Math.random()-0.5)*0.01;
            pos[j*3+1] += p.velocities[j*3+1];
            p.life[j] -= 0.01;
        }
        p.mesh.geometry.attributes.position.needsUpdate = true;
        p.mesh.material.opacity = Math.max(0, p.life[0]);
        if(p.life[0] <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }

    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/** -----------------------------------------------------------------
 * 启动与降级处理
 * ----------------------------------------------------------------- */
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(onResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 640, height: 480
});

cameraUtils.start().catch(err => {
    console.warn("摄像头启动失败，切换至鼠标模式", err);
    isCameraMode = false;
    document.getElementById('modeBtn').innerText = "模式: 鼠标";
    document.getElementById('video-container').style.display = 'none';
});

document.getElementById('modeBtn').onclick = () => {
    isCameraMode = !isCameraMode;
    document.getElementById('modeBtn').innerText = isCameraMode ? "模式: 摄像头" : "模式: 鼠标";
};

initThree();
</script>
</body>
</html>